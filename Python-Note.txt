- å‚³å…¥åƒæ•¸

scriptåç¨±ä¹‹å¾Œçš„å…¶ä»–åƒæ•¸ï¼Œå°‡è½‰æ›ç‚ºlistçš„stringsæŒ‡æ´¾çµ¦sys moduleçš„argvè®Šæ•¸

èˆ‰ä¾‹ï¼Œå‘¼å« py sample.py p1 p2

æª”æ¡ˆå…§å®¹
import sys
print(argv[0]); // sample.py
print(argv[1]); // p1
print(argv[1]); // p2

- Python åŸå§‹æª”é è¨­ä»¥ UTF-8 ç·¨ç¢¼
- è®Šæ›´ç·¨ç¢¼åœ¨æª”æ¡ˆé–‹é ­æ–°å¢
# -*- coding: cp1252 -*-

é™¤æ³•
17 / 3  # å›å‚³æµ®é»æ•¸

é™¤æ³•
17 // 3  # ä¸å›å‚³æµ®é»æ•¸

å››æ¨äº”å…¥
print(round(2.666666, 2)) # 2.67

æ¬¡æ–¹
5 ** 2 # 25
2 ** 7  # 128

python ä¸æ”¯æ´ ++ 

+= -= *= /=

ç­‰è™Ÿ
>>>
>>> width = 20
>>> height = 5 * 9
>>> width * height
900

In interactive mode, the last printed expression is assigned to the variable _
>>>
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06

è¼ƒå¤§çš„æ•¸å­—å¯ä»¥ç”¨_ä¾†åˆ†éš”ï¼Œæ˜“æ–¼é–±è®€
123_456_789 

_æ˜¯read-only

å…¶ä»–æ•¸å­— Deciaml/Fraction

#
# éš¨æ©Ÿ
#
import random
random_number =  random.randint(1,10)
random_number = random.random() 0.0000 ~ 0.99999

random.shuffle(list) # å¯ä»¥æ‰“äº‚li
random.choice(list) # éš¨æ©Ÿé¸å–ä¸€å€‹å€¼

å­—ä¸²
"{:.2f}".format(2.6) # 2.60
"{:.2f}".format(2.622) # 2.6
"{:.2f}".format(2.629) # 2.63 æœ‰å››æ¨äº”å…¥

"TEST".lower() # è½‰å°å¯«
"TEST".count('t') # å–å¾—å­—ä¸²å‡ºç¾æ¬¡æ•¸
"we're right".title() # "We're Right"

å–®å¼•è™Ÿï¼Œé›™å¼•è™Ÿçš†å¯è¡¨ç¤ºå­—ä¸²
>>> 'doesn\'t'  # "doesn't"
>>> "doesn't"   # "doesn't"
>>> '"Yes," they said.'   # '"Yes," they said.'
>>> "\"Yes,\" they said." # '"Yes," they said.' escaped
>>> '"Isn\'t," they said.'#

print()æ–¹æ³•æœƒå¿½ç•¥å…©å´closing quoteä¸¦å°å‡ºescaped/specialå­—å…ƒ
>>> '"Isn\'t," they said.' 		# '"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')	# "Isn't," they said.
>>> s = 'First line.\nSecond line.'  # æˆ‘å€‘æƒ³è¦ \n è¡¨ç¤ºæ›è¡Œ
>>> s  # 'First line.\nSecond line.' æ²’æœ‰ print(), \n æœƒåœ¨ output

>>> print(s)  
First line.
Second line. # æœƒæ›è¡Œ



é‚è¼¯é‹ç®—å­ : and or not

#
# è½‰å‹
#
num = str(20) # intè½‰å‹


ä½¿ç”¨rä¾†è¡¨ç¤ºraw string
>>> print('C:\some\name')  # \nè¦–ç‚ºæ›è¡Œ
C:\some
ame
>>> print(r'C:\some\name')  # å­—ä¸²å‰åŠ r
C:\some\name

å¤šè¡Œçš„å­—ä¸²
ç”¨"""...""" æˆ–æ˜¯ '''...'''

å­—ä¸²concateç”¨+ï¼Œé‡è¤‡ç”¨*
>>> 3 * 'un' + 'ium' #'unununium'

å­—ä¸²é–“çš„ç©ºç™½æœƒè‡ªå‹•é€£æ¥
'Py' 'thon' # 'Python'
å¯ä»¥ç”¨ä¾†é•·å¥å­æ›è¡Œ
åƒ…é©ç”¨æ–¼string literalsï¼Œè®Šæ•¸ä¸è¡Œï¼Œæœ‰è®Šæ•¸çš„concateåªèƒ½ç”¨+

Slicing :
æ²’æœ‰charå‹åˆ¥ï¼Œpythonåªæœ‰é•·åº¦1çš„å­—ä¸²
stringå¯ä»¥indexed

>>> word = 'Python'
>>> word[0]   # 'P' ç¬¬1å€‹
>>> word[-1]  # 'n' å€’æ•¸ç¬¬1å€‹
>>> word[-2]  # 'o' å€’æ•¸ç¬¬2å€‹
>>> word[-6]  # 'P' å€’æ•¸ç¬¬6å€‹

è² æ•¸indexå¾-1é–‹å§‹ç®—èµ·

>>> word[0:2]  # 'Py' 0 (åŒ…å«) åˆ° 2 (ä¸åŒ…å«)
>>> word[2:5]  # 'tho' 2 (åŒ…å«) åˆ° 5 (ä¸åŒ…å«)
>>> word[:2]   # 'Py' é–‹å§‹åˆ° position 2 (ä¸åŒ…å«)
>>> word[4:]   # 'on' 4 (åŒ…å«) åˆ°çµæŸ
>>> word[-2:]  # 'on' -1 (åŒ…å«) åˆ°çµæŸ

Slicingå¯ä»¥è™•ç†out of range
>>> word[4:42] # 'on'
>>> word[42:]  # '' 

å­—ä¸²ä¹Ÿæ˜¯immutable
>>> word[0] = 'J' # éŒ¯èª¤

å­—ä¸²é•·åº¦ len()

*** Lists ***

squares = [1, 4, 9, 16, 25] // ç”¨ä¸­æ‹¬è™Ÿï¼Œé€—è™Ÿéš”é–‹
>>> squares[0]  # 1
>>> squares[-1] # 25
>>> squares[-3:]  # å›å‚³æ–°çš„ list [9, 16, 25]
>>> squares[1:5:2} #
slicing æœƒå›å‚³æ–°çš„ list

>>> squares[:] # å›å‚³ä¸€å€‹å…¨æ–°ä¸€æ¨£çš„list [1, 4, 9, 16, 25]

æœ‰incrementçš„slicing 
print(squares[0:5:2])  #[1, 9, 25] 
print(squares[5:1:-1]) #[25, 16, 9] 
print(squares[5:0:-1]) #[25, 16, 9, 4] 
print(squares[5:0:-2]) #[25, 9]  
print(squares[::-1])   #[25, 16, 9, 4, 1]

listä¹Ÿå¯ä»¥concate
>>> squares + [36, 49, 64, 81, 100] # å›å‚³ [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

listæ˜¯mutableçš„ï¼Œèˆ‡stringä¸åŒ
>>> cubes = [1, 8, 27, 65, 125]  
>>> cubes[3] = 64  
>>> cubes # [1, 8, 27, 64, 125] æˆåŠŸç½®æ›

>>> cubes.append(216)  # åŠ åˆ°å°¾
>>> cubes.append(7 ** 3)  # åŠ åˆ°å°¾
>>> cubes # [1, 8, 27, 64, 125, 216, 343]

ç½®æ›listä¸­çš„å…ƒç´ 
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] ä¸­é–“çš„ç‰©ä»¶è¢«æ›äº†

ç§»é™¤listä¸­çš„å…ƒç´ 
>>> letters[2:5] = []
>>> letters # ['a', 'b', 'f', 'g'] ä¸­é–“çš„ç‰©ä»¶è¢«ç§»é™¤äº†

æ¸…ç©ºlist
letters[:] = []

listçš„æœ€å¤§å€¼ï¼Œæœ€å°å€¼
list.max()
list.min()

listé•·åº¦len()
>>> len(letters) # 4

listè£¡åŒ…å«list
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x # [['a', 'b', 'c'], [1, 2, 3]]
>>> x[0] # ['a', 'b', 'c']
>>> x[0][1] #b

å¤šé‡assignment
>>> a, b = 0, 1

å³å´çš„expressionåœ¨assignmentå‰æœƒå…ˆè¢«åŸ·è¡Œã€‚
>>> a, b = b, a+b

å³å´çš„è¡¨é”å¼å¾å·¦åˆ°å³è¨ˆç®—ã€‚
... a, b = 0, 1
>>> while a < 10:
...		a, b = b, a+b # a+b æœƒå…ˆåŸ·è¡Œ
...     print('a=',a , 'b=', b);
...     
a= 1 b= 1 # print çš„çµæœä¹‹é–“æœƒè‡ªå‹•æœ‰ç©ºç™½
a= 1 b= 2
a= 2 b= 3
a= 3 b= 5
a= 5 b= 8
a= 8 b= 13
a= 13 b= 21

whileè¿´åœˆå…§å®¹>0ç‚ºTrueï¼Œ0ç‚ºFalse
ä»»ä½•é•·åº¦>0çš„ç‰©ä»¶åœ¨whileè¿´åœˆå…§éƒ½æ˜¯Trueï¼Œ

print() çš„çµæœä¹‹é–“æœƒè‡ªå‹•æœ‰ç©ºç™½

å–®å¼•è™Ÿå­—ä¸²ï¼Œä¸ç”¨escapeé›™å¼•è™Ÿ
é›™å¼•è™Ÿå­—ä¸²ï¼Œä¸ç”¨escapeå–®å¼•è™Ÿ

>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... else:
...     print('More')

å¦å¤– if elif å¯ç”¨ä¾†å–ä»£å…¶ä»–èªè¨€çš„ switch

forè¿´åœˆ
>>> words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))

å¦‚æœæ²’æœ‰è¦ç”¨åˆ° for å¾Œçš„è®Šæ•¸ï¼Œå¯ä»¥ä½¿ç”¨ _

>>> words = ['cat', 'window', 'defenestrate']
>>> for _ in words:
...     print(')

iterate collectionæ™‚åŒæ™‚è¦ä¿®æ”¹collectionå®¹æ˜“å‡ºéŒ¯ï¼Œé€šå¸¸çš„åšæ³•æ˜¯è¤‡è£½ä¸€å€‹æ–°çš„collection

# å»ºç«‹ä¸€å€‹ sample collection (æ­¤è™•ä½¿ç”¨çš„æ˜¯dict)
users = {'Hans': 'active', 'Ã‰lÃ©onore': 'inactive', 'æ™¯å¤ªéƒ': 'active'}
print(type(users)); # <class 'dict'>

å¦ä¸€ç¨®å»ºç«‹dictçš„æ–¹å¼
users = dict()

users['a'] = 'A'
users['a'] = 'B' # å–ä»£
print(users['a'] )  # B

users['b'] # éŒ¯èª¤
users.get('b') # ç„¡è³‡æ–™æ™‚å›å‚³ None <class 'NoneType'>
users.get('b', 'tbd') # ç„¡è³‡æ–™æ™‚å›å‚³è‡ªè¨‚å­—ä¸²
users.get('b', 20) # ç„¡è³‡æ–™æ™‚å›å‚³ä¹Ÿå¯è‡ªè¨‚å‹åˆ¥

ä¸€æ¬¡æ›´æ–°å¤šç­†å¯ç”¨update()
new_users = {'John': 'active', 'Snow': 'inactive', 'Rick0': 'active'}
users.update(new_users) #å°‡new_usersåŠ å…¥users

åˆªé™¤
del users[key]

åˆªé™¤å¾Œå–å¾—value
tmp = users.pop(key)

å–å¾—æ‰€æœ‰keys
users.keys()
dict_keys(['Hans', 'Ã‰lÃ©onore', 'æ™¯å¤ªéƒ', 'John', 'Snow', 'Rick0']) #<class 'dict_keys'>

å–å¾—æ‰€æœ‰values
users.values()
dict_values(['active', 'inactive', 'active', 'active', 'inactive', 'active']) #<class 'dict_values'>

å–å¾—æ‰€æœ‰key/value
users.items()

æ˜¯å¦æœ‰KEY
'key' in users # å›å‚³Trueæˆ–False

==å¯åˆ¤æ–·å…©å€‹dictæ˜¯å¦å«æœ‰ç›¸åŒçš„key/valueçµ„åˆï¼Œé †åºä¸é‡è¦
 
isé‹ç®—å­å¯åˆ¤æ–·æ˜¯å¦ç‚ºç›¸åŒçš„ç‰©ä»¶
print(users is new_users) # å›å‚³False


dicté¡ä¼¼HashMapï¼Œkeyå€¼å”¯ä¸€
å–å¾—valueä½¿ç”¨users[key]

# Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Strategy:  Create a new collection
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status

range() æ–¹æ³•
>>> for i in range(5): # 0-4
...     print(i)  # 0 1 2 3 4 5

>>> list(range(5, 10)) # å¯ä»¥è¨­å®šèµ·å§‹æ•¸å­— [5, 6, 7, 8, 9] <class 'list'>
>>> list(range(0, 10, 3)) # å¯ä»¥è¨­å®šé–“éš” [0, 3, 6, 9]
>>> list(range(-10, -100, -30)) #[-10, -40, -70]

å·¡è¿´listçš„æ–¹æ³•
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])

range(10) å›å‚³ä¸€å€‹ range(0, 10) <class 'range'>

>>> sum(range(4))  # 0 + 1 + 2 + 3
6

é€™å€‹elseæ˜¯é‡å°å…§å±¤çš„forè¿´åœˆï¼Œç•¶forè¿´åœˆç„¡breakæ™‚å‰‡æœƒåŸ·è¡Œelse
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')

pass 
æœ¬èº«æ²’ç”¨é€”ï¼Œç®—æ˜¯ä¸€å€‹placeholderï¼Œå¸¸ç”¨æ–¼å»ºç«‹ä¸€å€‹ç©ºçš„é¡åˆ¥
>>> class MyEmptyClass:
...     pass

æˆ–æ˜¯ç”¨æ–¼æ–¹æ³•ç•¶ä½œplaceholder
>>> def initlog(*args):
...     pass   # Remember to implement this!

# matchæœ‰ä»¥ä¸‹pattern
#
# Literal Patterns
# Wildcard Patterns
# OR Pattern
# AS Pattern
#
def http_error(status):
    match status:
        # literal pattern
        case 400:
            return "Bad request"
        # OR pattern / AS Pattern
        case 401 | 403 | 404 as errorCode: 
            return "Not allowed"
        # wildcard pattern 
        case _:
            return "Something's wrong with the internet"

# Wildcard Patterns ä¸­çš„ _ å¯ä»¥ match æ‰€æœ‰ç‰©ä»¶ï¼Œè¦å®šåªèƒ½æ”¾æœ€å¾Œ
# å› ç‚º OR Patterns ç„¡æ³•åˆ†è¾¨å…§å®¹ï¼Œæ‰€ä»¥ç”¨ as å°‡å€¼ bind åˆ°è®Šæ•¸

# 
# Capture Patterns
#
def point(point):
    match point: # é€™è£¡å®šç¾©çš„ point æ˜¯ tuple(aka ä¸èƒ½ä¿®æ”¹çš„list)
        case (0, 0):
            print("Origin")        
        case (x, 0):
            print(f"X={x}") # æœƒåš bind
        case (x, y): # å¦‚åŒ Unpacking Assignment (x, y) = point.
            print(f"X={x}, Y={y}")

# 
# Class Patterns
#
class Point:
    x: int
    y: int

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Origin")
        case Point(x=0, y=y):
            print(f"Y={y}")
        case Point(x=x, y=0):
            print(f"X={x}")
        case Point():
            print("Somewhere else")
        case _:
            print("Not a point")

# è‡ªè¨‚çš„ class éœ€åœ¨ pattern ä¸­æŒ‡å®šå±¬æ€§åç¨±
# æœ‰å…©å€‹æ–¹æ³•å¯ä»¥ä¸ç”¨æŒ‡å®šå±¬æ€§åç¨±
# 1. ä½¿ç”¨ dataclassï¼šé€™å¯ä»¥è®“ class å¯¦ä¾‹çš„å±¬æ€§æ“æœ‰'é †åº'(positional argument)ï¼Œç„¡éœ€åœ¨ pattern ä¸­æŒ‡å®šå±¬æ€§åç¨±
# 2. å®šç¾©__match_args__

from dataclasses import dataclass


command = input("what are you doing next")

# [action, action2] = command.split() # å¦‚æœè¼¸å¤šæ–¼2å€‹ï¼Œunpackæœƒå¤±æ•—ï¼Œsplit()ç”¨ç©ºç™½ç•¶ä½œåˆ†éš”

match command.split():
	case [action]: # åªæœ‰è¼¸å…¥1å€‹å­—
		print('action only')
	case [action, obj]: # è¼¸å…¥2å€‹å­—
		print('action and obj')

match command.split():
    case ["quit"]:
        print("Goodbye!")        
    case ["look", obj] if obj == 'left': # uf å³æ‰€è¬‚çš„ Guard
        print("look left!")        
    case ["get", obj]: # get è·Ÿ go çš„è®Šæ•¸åç¨±å¯ä»¥è¨­æˆä¸åŒ
        print("get!") 
    case ["go", direction]: # get è·Ÿ go çš„è®Šæ•¸åç¨±å¯ä»¥è¨­æˆä¸åŒ
        print("go!")

		
match command.split():
    case ["drop", *objects]:
        print(type(objects)) #<class 'list'>
        for obj in objects:
            print(obj)
    case _:
        print('wildcard')
# å¦‚åŒ sequence unpackingï¼Œä¸€å€‹patternä¸å¯æœ‰è¶…éä¸€å€‹*


doom = ["first", ("l", "r"), "a", "b", "c"]

match doom:
    case ["first", (left, right), *rest]:
        print(type(rest)) 
        for obj in rest:
            print(obj) # a b c
        print(left, right) # l r
    case _:
        print('wildcard')
		
match command.split():    
    case ["north"] | ["go", "north"]:
        print("north")
    case ["get", obj] | ["pick", "up", obj] | ["pick", obj, "up"]:
        print('56')
		
match command.split():    
    case ["north"] | ["go", "north"]:
        print("north")
    #ä¸‹é¢æœƒéŒ¯èª¤ï¼Œalternative patterns bind different names
    #case ["get", obj, obj2] | ["pick", "up", obj] | ["pick", obj, "up"]:
        #print('50')
# Or pattern ä¸‹åŒä¸€å€‹patternçš„alternativeså¿…é ˆç¶å®šä¸€æ¨£çš„è®Šæ•¸
# [1, x] | [2, y] ä¸è¡Œ
# [1, x] | [2, x] å¯ä»¥

# å°‡ORçš„çµæœå­˜å…¥direction
match command.split():
    case ["go", ("north" | "south" | "east" | "west") as direction]:
        print(direction)
		
match command.split():
    case ["go", "north"] | ["go", "south"] | ["go", "east"] | ["go", "west"] as direction:
        print(direction)

class Room:
	exits:list

current_room = Room()
current_room.exits = ["north","south"]
		
match command.split():
    case ["go", direction] if direction in current_room.exits:
        print(direction)
    case ["go", _]:
        print("Sorry, you can't go that way")

class Person:	
	fname:str
	lname:str
	age:int
	
john = Person()
john.fname = 'John'
john.lname = 'Wicks'

match john:	
	# match named attribute å¦‚ä¸‹
	case Person(lname='Wicks', fname='John'): # é †åºäº¤æ›ï¼Œå¯ä»¥match
		print('1st John')
	case Person('John', 'Wicks'): # Person accepts 0 positional sub-patterns (2 given)
		print('1st John')
	case Person(fname='John', lname='Wicks'): # å¯ä»¥match
		print('2nd John')
		
# ä¸Šé¢çš„éŒ¯èª¤éœ€è¦åŠ å…¥ __match_args__ = ("position", "button")

class Person:	
	__match_args__ = ("fname", "lname") # è¨­å®š
	fname:str
	lname:str
	age:int
	
john = Person()
john.fname = 'John'
john.lname = 'Wicks'

match john:
	# ä¸éœ€è¦match named attributeï¼Œå› ç‚ºè¨­å®šäº†__match_args__
	case Person('John', 'Wicks'): # å¯ä»¥matchäº†
		print('1st John')
	case Person(lname='Wicks', fname='John'): # é †åºäº¤æ›ï¼Œå¯ä»¥match
		print('1st John')
	case Person(fname='John', lname='Wicks'): # å¯ä»¥match
		print('2nd John')

#å®šç¾©dataclassçš„è©±ä¹Ÿå®šç¾©positional argumentsï¼Œ'fname', 'lname', and 'age'
#é€™ä¸‰å€‹argumentsæ˜¯æœ‰é †åºçš„

@dataclass
class Person:	
	fname:str
	lname:str
	age:int
	
john = Person('John','Wicks',20) # åˆå§‹åŒ– dataclass

match john:	
	case Person('John', 'Wicks'): # å¯ä»¥match
		print('1st John')
	case Person(lname='Wicks', fname='John'): 
		print('1st John')	
	case Person(fname='John', lname='Wicks'): 
		print('2nd John')
#
# Mapping pattern
#
# {"bandwidth": b, "latency": l} å–å¾— "bandwidth" èˆ‡ "latency" çš„å€¼å¾dict. 
# ä¸åƒ sequence patterns, å…¶ä»–çš„KEYè¢«å¿½ç•¥äº†.ä½¿ç”¨ **rest å¯ä»¥ä¿ç•™å…¶ä»–çš„KEY. (ä½†æ˜¯ **_ æ˜¯ä¸è¢«å…è¨±çš„)
	
actions = [{"text": "The shop keeper says 'Ah! We have Camembert, yes sir'", "color": "blue", "name":"Doc Rivers","age":65,"team":"LA Clippers"}
,{"sleep": 3},{"sound": "filename.ogg", "format": "ogg"}]

# é€™è£¡çš„**restå°±æ˜¯ä¸€å€‹ kwargs (keyword-args)

for action in actions:
    match action:
        case {"text": message, "color": c, **rest}:
            print(type(rest)) #<class 'dict'>
            for key in rest:
                print(key, rest[key])
            print('color=',c)
            print('message=',message)
        case {"sleep": duration}:
            print('sleep=',c)
        case {"sound": url, "format": "ogg"}:
            print('url=',url)
        case {"sound": _, "format": _}:
            warning("Unsupported audio format")

#
# æ¯”å°å…§å»ºå‹åˆ¥ Matching builtin classes
#

for action in actions:
    match action:
        case {"text": str(message), "color": str(c)}:            
            print('do something 2')
        case {"sleep": float(duration)}:
            print('do something 3')
        case {"sound": str(url), "format": "ogg"}:
            print('do something 4')
        case {"sound": _, "format": _}:
            warning("Unsupported audio format")
# {"text": str() as message, "color": str() as c}
# ç¢ºä¿textå’Œcoloréƒ½æ˜¯strï¼Œä¸Šè¿°å¯«æ³•ä¹Ÿå¯ä»¥ç¸®æ¸›æˆå¦‚ä¸‹
# {"text": str(message), "color": str(c)}

#
# Sequence Pattern
#
# [x, y, *rest] and (x, y, *rest) éƒ½ç”¨æ–¼ unpacking assignments. * è™Ÿå¾Œä¹Ÿå¯ä»¥æ˜¯ _ï¼Œåƒ (x, y, *_)ï¼Œå¦‚æ­¤åªæœƒbindå…©å€‹è®Šæ•¸ï¼Œå…¶ä»–ä¸æœƒ


from enum import Enum
class Color(Enum):
    RED = 'red'
    GREEN = 'green'
    BLUE = 'blue'

color = Color(input("Enter your choice of 'red', 'blue' or 'green': "))

match color:
    case Color.RED:
        print("I see red!")
    case Color.GREEN:
        print("Grass is green")
    case Color.BLUE:
        print("I'm feeling the blues :(")

		
food = ['a','b','c','d','k']
match food:
	# case ['a','b','c', _]:
		# print("wild")
	case ['a','b','d', *other]:
		print(f"{','.join(other)}'")
	case ['a', *other, 'e']:
		print(f"{','.join(other)}'")
	case['a', _] if "c" in food:
		print('in')
	case {"a":"", **kwargs}:
		print('desert')



https:/
5349023.github.io/articles/2021-03/py-structural-pattern-matching/
https://medium.com/short-bits/python-3-10-match-a-new-way-to-find-patterns-8452d1460407
https://peps.python.org/pep-0635/
https://benhoyt.com/cv/#about-me
https://www.geeksforgeeks.org/python-star-or-asterisk-operator/

#
# Python æŒ‡æ´¾å€¼çš„æ–¹å¼èªªæ˜ call-by-assignment
#
# Assigning to a variable name in Python makes the name bind to a different value 
# from what it currently was bound to (if indeed it was already bound), 
# rather than changing the value it currently binds to:

# å°‡ä¸€å€‹å€¼æŒ‡æ´¾çµ¦ä¸€å€‹è®Šæ•¸åç¨±ï¼Œè¡¨ç¤ºè©²åç¨±æœƒbindåˆ°ä¸€å€‹ä¸åŒçš„å€¼(value)
# è€Œä¸æ˜¯åŸä¾†bindçš„å€¼ï¼ŒæŒ‡æ´¾é€™å€‹å‹•ä½œä¸¦éè®Šæ›´åŸå…ˆbindçš„å€¼

a = 7   # Create 7, bind a to it.
        #     a -> 7

b = a   # Bind b to the thing a is currently bound to.
        #     a
        #      \
        #       *-> 7
        #      /
        #     b

a = 42  # Create 42, bind a to it, b still bound to 7.
        #     a -> 42
        #     b -> 7


# Where the underlying data is immutable (cannot be changed), that usually makes Python look as if it's behaving identically 
# to the way other languages do (C and C++ come to mind). That's because the 7 (the actual object that the names are bound to) cannot be changed.

# But, for mutable data (same as using pointers in C or references in C++), 
# people can sometimes be surprised because they don't realise that the value behind it is shared:

a = [1,2,3]     # a -> [1,2,3]
print(a) # [1, 2, 3]

b = a           # a,b -> [1,2,3]
print(b) # [1, 2, 3]

a[1] = 42       # a,b -> [1,42,3]
print(a) 
print(b)
# éƒ½æ˜¯ [1, 42, 3]

# You need to understand that a[1] = 42 is different to a = [1, 42, 3]. The latter is an assignment, 
# which would result in a being re-bound to a different object, and therefore independent of b.

# é‡é» : å¦‚æœç”¨ = æŒ‡æ´¾æ–°çš„å€¼åˆ°è®Šæ•¸åç¨±ï¼Œåƒ a = [1,42,3]ï¼Œb é‚„æ˜¯æœƒæŒ‡å‘åŸæœ¬çš„ [1,2,3]

def set_list(list):
    list = ["A", "B", "C"]
    return list
 
def add(list):
    list.append("D") # += æ•ˆæœç­‰åŒ append
    return list
 
my_list = ["E"]
 
print(set_list(my_list))
 
print(add(my_list))


# The former is simply changing the mutable data that both a and b are bound to, which is why it affects both.


# å¦ä¸€ç¯‡èªªæ³•

If you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.

If you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object.

ä¾‹å¦‚ def foo(bar): é€™å€‹ function çš„åƒæ•¸å‚³éï¼Œå…¶å¯¦æ˜¯åœ¨ foo çš„ local namespace è£¡å¹«å‚³é€²å»çš„ç‰©ä»¶ç¶å®šäº†ä¸€å€‹å«åš bar çš„åå­—ï¼ˆæ‰€è¬‚çš„ assignmentï¼‰ï¼›å¦‚æœä½ åœ¨ foo è£¡ re-assign äº†ä¸€å€‹æ–°çš„ç‰©ä»¶çµ¦ barï¼Œå¯¦éš›ä¸Šæ˜¯æŠŠ bar é€™å€‹åå­—ç¶å®šåˆ°é‚£å€‹æ–°çš„ç‰©ä»¶ã€‚

mutable objects: list, dict, set çš„è¡Œç‚ºåŒ call-by-reference
immutable objects: boolean, int, float, long, str, unicode, tuple çš„è¡Œç‚ºåŒ call-by-value
ä¸éå¦‚æœä½ æŠŠä¸€å€‹ mutable ç‰©ä»¶æ”¾é€² immutable ç‰©ä»¶è£¡ï¼Œä¾‹å¦‚æŠŠ list æ”¾é€² tuple è£¡ï¼Œå‰‡ä¿®æ”¹äº† list ä¹‹å¾Œï¼Œé‚£å€‹ tuple è£¡çš„ list ä¹Ÿæ˜¯æœƒè¢«ä¿®æ”¹ã€‚

a_list = [1, 2, 3]
a_tuple = (a_list, 'a', 'b', 'c')
a_list.append(4)
Assignment is the binding of a name to an object: name = 'Molly'.
Assignment between names doesn't create a new object, both names are simply bound to the same object: nickname = name.

name = 'Mollie'
name = 'Vinta'
æ‰€è¬‚çš„ assign é€™å€‹å‹•ä½œï¼Œå…¶å¯¦æ˜¯å¹« 'Mollie' é€™å€‹å­—ä¸²å–ä¸€å€‹åå­—å«åš nameï¼Œæ‰€ä»¥å¦‚æœä½ åˆåŠ ä¸Šä¸€å¥ name = 'Vinta'ï¼Œå¯¦éš›ä¸Šæ˜¯å»ºç«‹äº†ä¸€å€‹æ–°çš„ç‰©ä»¶ï¼ˆå­—ä¸² 'Vinta'ï¼‰ï¼Œå†æŠŠé€™å€‹æ–°å­—ä¸²ç¶å®šåˆ° name é€™å€‹åå­—ã€‚

# if bar refers to a mutable object
def foo(bar):
    bar.append('new value')
    print(bar)
    # output: ['old value', 'new value']

answer_list = ['old value', ]
foo(answer_list)
print(answer_list)
# output: ['old value', 'new value']

# if bar refers to an immutable object
def foo(bar):
    bar = 'new value'
    print(bar)
    # output: 'new value'

answer_list = 'old value'
foo(answer_list)
print(answer_list)
# output: 'old value'

# if bar refers to a mutable object and re-assign it in foo
def foo(bar):
    bar = ['new value', ]
    print(bar)
    # output: ['new value', ]

answer_list = ['old value', ]
foo(answer_list)
print(answer_list)
# output: ['old value', ]

#
# æ–¹æ³•
#

>>> def fib(n):    # write Fibonacci series up to n
...     """Print a Fibonacci series up to n.""" 
...     a, b = 0, 1
...     while a < n:
...         print(a, end=' ')
...         a, b = b, a+b
...     print()

# æ–¹æ³•çš„ç¬¬ä¸€è¡Œæ˜¯ docstringsï¼Œç”¨ """ """ 


# æ–¹æ³•åŸ·è¡Œæ™‚ï¼Œæœƒä½¿ç”¨ä¸€å€‹å„²å­˜è©²æ–¹æ³•å€åŸŸè®Šæ•¸çš„
# æ›´æº–ç¢ºåœ°èªªï¼Œå‡½æ•¸ä¸­çš„æ‰€æœ‰è®Šæ•¸è³¦å€¼(variable assignments)éƒ½å°‡å€¼å­˜å„²åœ¨ local symbol table ä¸­
# è®Šæ•¸ reference é †åº
	# é¦–å…ˆåœ¨ local symbol table ä¸­æŸ¥æ‰¾ï¼Œ
	# ç„¶å¾Œåœ¨ function çš„ local symbol table ä¸­æŸ¥æ‰¾ï¼Œ
	# ç„¶å¾Œåœ¨ global symbol table ä¸­æŸ¥æ‰¾
	# æœ€å¾Œåœ¨ built-in names table ä¸­æŸ¥æ‰¾ã€‚
	
# Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function, although they may be referenced.	

# å…¨åŸŸè®Šæ•¸èˆ‡æ–¹æ³•å…§çš„è®Šæ•¸ï¼Œåœ¨æ–¹æ³•å…§ä¸èƒ½ç›´æ¥ assign å€¼ï¼Œä½†ä»–å€‘å¯ä»¥è¢« reference

#The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object).

# å‘¼å«æ–¹æ³•æ™‚å‚³å…¥çš„åƒæ•¸æœƒè¢«æ”¾åˆ°ä¸€å€‹ local symbol tableï¼Œæ›å¥è©±èªªï¼Œåƒæ•¸å‚³éçš„æ–¹å¼æ˜¯ Call-By-Object-Reference 

# When a function calls another function, or calls itself recursively, a new local symbol table is created for that call.

# æ¯å€‹æ–¹æ³•å‘¼å«æœƒæœ‰è‡ªå·±çš„ local symbol table

# æ²’æœ‰å›å‚³å€¼çš„æ–¹æ³•å…¶å¯¦æœƒå›å‚³ None ç‰©ä»¶

# æ–¹æ³•å®šç¾©æ™‚ï¼Œå¯è¨­å®šåƒæ•¸é è¨­å€¼
def ask_ok(prompt, retries=4, reminder='Please try again!'):

# in é—œéµå­—
if ok in ('y', 'ye', 'yes'): 
# è®Šæ•¸ ok çš„å€¼æ˜¯å¦åœ¨å³é‚Šçš„ sequence ä¸­

# The default values are evaluated at the point of function definition in the defining scope
# é è¨­å€¼æ˜¯åœ¨æ–¹æ³•å®šç¾©çš„ç•¶ä¸‹å°±æ±ºå®š

i = 5

def f(arg=i):
    print(arg)

i = 6
f() # å°å‡º5ï¼Œä¸æ˜¯6

# é‡è¦è­¦å‘Š: é è¨­å€¼åªevaluateä¸€æ¬¡ï¼Œç•¶é è¨­å€¼ç‚º mutable ç‰©ä»¶åƒæ˜¯list, dictionary, æˆ–æ˜¯ç‰©ä»¶æœƒæœ‰ä¸åŒ
def f(a, L=[]):
    L.append(a)
    return L

print(f(1)) # [1]
print(f(2)) # [1, 2] å› ç‚ºLçš„å€¼å·²ç¶“è¢«æ”¹è®Šäº†
print(f(3)) # [1, 2, 3]

# ä¸è¦é è¨­å€¼ä¸åœ¨å‘¼å«é–“åˆ†äº«

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
	
# Keyword Arguments

def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'): 
    print("-- This parrot wouldn't", action, end=' ') # end=' ' è¡¨ç¤ºä¸æ›è¡Œï¼Œé è¨­ end çš„å€¼ç‚º '\n'
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")

# ä»¥ä¸‹å‘¼å« OK
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

# ä»¥ä¸‹å‘¼å«ä¸ OK
parrot()                     # required argument missing
parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
parrot(110, voltage=220)     # duplicate value for the same argument
parrot(actor='John Cleese')  # unknown keyword argument
parrot(1000, voltage=1000)	 # multiple values for argument 'voltage'

# ç•¶æœ€å¾Œä¸€å€‹åƒæ•¸æ˜¯ **nameï¼Œé€™æ˜¯ä¸€å€‹ dict åŒ…å«'å…¶ä»–'æ‰€æœ‰çš„ keyword arguments 
# æ­é… *name å¯ä»¥å–å¾—ä¸€å€‹ tuple åŒ…å«'å…¶ä»–'çš„åƒæ•¸

def cheeseshop(kind, *arguments, **keywords):    
    for arg in arguments:
        print(arg) # a b
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw]) # A B C

cheeseshop("Limburger", "a", "b", shopkeeper="A", client="B", sketch="C")

# kwargs çš„åˆ—å°é †åºä¸€å®šæ˜¯keyword argumenå‚³å…¥çš„é †åº

#
# Special parameters
#
# / å’Œ * æ˜¯ç‚ºäº†è®“é–‹ç™¼äººå“¡å¯ä»¥å¿«é€Ÿåˆ†æ¸…æ¥š
# Positional-Only, Positional-or-Keyword, Keyword-Only Arguments ç”¨çš„

def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
		 
# Positional-Only Parameters
# åœ¨ / å‰é¢çš„åƒæ•¸å‚³å…¥ä¸å¯ä»¥ç”¨keyword argumentçš„æ–¹å¼å‚³å…¥
# / æ˜¯ optional çš„

# Positional-or-Keyword Arguments
# åœ¨ * å‰é¢çš„åƒæ•¸å‚³å…¥å¯ç”¨positional æˆ– keyword argumentçš„æ–¹å¼å‚³å…¥

# Keyword-Only Parameters
# åœ¨ * å‰é¢çš„åƒæ•¸å‚³å…¥åªèƒ½ç”¨keyword argumentçš„æ–¹å¼å‚³å…¥

def foo(name, **kwds):
    return 'name' in kwds
# æ°¸é ç„¡æ³•å›å‚³ True å› ç‚º'name'æ°¸é ç¶å®šç¬¬ä¸€å€‹åƒæ•¸
	
foo(1, **{'name': 2}) # TypeError: foo() got multiple values for argument 'name'

# è¦è§£æ±ºä¸Šè¿°å•é¡Œå¯ä»¥ç”¨ / å¦‚ä¸‹

def foo(name, /, **kwds):
    return 'name' in kwds
foo(1, **{'name': 2}) # True

# æ›å¥è©±èªª, positional-only parameters çš„åç¨±å¯ä»¥ç”¨åœ¨ **kwds è€Œä¸æœƒé€ æˆæ¨¡æ“¬å…©å¯çš„æƒ…å½¢

def foo(name, *, **kwds)
# éŒ¯èª¤ named arguments must follow *ï¼Œæ˜Ÿè™Ÿå¾Œéœ€æ¥ named arguments

# ä½¿ç”¨ positional-only å¦‚æœä¸æƒ³è®“ä½¿ç”¨è€…çŸ¥é“åƒæ•¸çš„åç¨±ï¼Œé€™åœ¨åƒæ•¸æ²’æœ‰å¯¦éš›æ„ç¾©æ™‚æ˜¯å¯¦ç”¨çš„ï¼Œ å¦‚æœä½ æƒ³è¦ç¢ºä¿å‘¼å«æ™‚åƒæ•¸çš„é †åºï¼Œor if you need to take some positional parameters and arbitrary keywords.

# ä½¿ç”¨ keyword-only ç•¶åå­—æœ‰æ„ç¾©æˆ–æ˜¯ç•¶æ–¹æ³•å› åƒæ•¸åç¨±è€Œæ›´å®¹æ˜“äº†è§£æ™‚ï¼Œæˆ–æ˜¯è¦é¿å…ä½¿ç”¨è€…ä¾è³´å‚³éåƒæ•¸çš„é †åº

# é—œæ–¼ APIï¼Œä½¿ç”¨ positional-only å¯é¿å…å› ç‚ºæœªä¾†åƒæ•¸åç¨±æ”¹è®Šé€ æˆ API å£æ‰

#
# Arbitrary Argument Lists
#

def write_multiple_items(file, separator, *args): # *args æ˜¯ tuple
    file.write(separator.join(args))
	
# é€šå¸¸ï¼Œé€™äº›å¯è®Šåƒæ•¸å°‡åœ¨å½¢å¼åƒæ•¸æ¸…å–®ä¸­æ’åœ¨æœ€å¾Œï¼Œå› ç‚ºå®ƒå€‘æœƒæ”¶é›†å‚³éçµ¦å‡½æ•¸çš„æ‰€æœ‰å‰©é¤˜è¼¸å…¥åƒæ•¸ã€‚åœ¨ *args åƒæ•¸ä¹‹å¾Œå‡ºç¾çš„ä»»ä½•å½¢å¼åƒæ•¸éƒ½æ˜¯"keyword-only"åƒæ•¸ï¼Œé€™æ„å‘³è‘—å®ƒå€‘åªèƒ½ç”¨ä½œ keyword è€Œä¸æ˜¯ positional argumentsã€‚

#
# Unpacking Argument Lists
#
# ç•¶è¦å‚³å…¥çš„åƒæ•¸å·²ç¶“æ˜¯ list æˆ– tuple æ™‚ï¼Œä½†è¦å‚³å…¥çš„å‡½æ•¸éœ€è¦ separate positional argumentsï¼Œ
# æ­¤æ™‚å°±éœ€è¦ unpackedï¼Œèˆ‰ä¾‹ä¾†èªªï¼Œrange()æ–¹æ³•éœ€è¦å…©å€‹åˆ†é–‹çš„è®Šæ•¸ï¼Œä½œç‚ºèµ·å§‹èˆ‡çµæŸï¼Œ
# ç•¶æ²’è¾¦æ³•å–å¾—å…©å€‹åˆ†é–‹çš„æ•¸ï¼Œä½¿ç”¨ * é‹ç®—å­ä¾†å°‡ tuple æˆ– list åš unpack å‚³å…¥æ–¹æ³•
 
 
list(range(3, 6))            # normal call with separate arguments [3, 4, 5]
args = [3, 6]
list(range(*args))            # call with arguments unpacked from a list [3, 4, 5]

# åŒæ¨£é“ç†, dictionaries å¯ä»¥ä½¿ç”¨ ** é‹ç®—å­å‚³é keyword arguments
 
def parrot(voltage, state='a stiff', action='voom'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.", end=' ')
    print("E's", state, "!")
d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
parrot(**d)

#
# Lambda Expressions
#
# å°å‹åŒ¿åæ–¹æ³•å¯ä»¥ç”¨ lambda é—œéµå­—å»ºç«‹ï¼ŒLambda æ–¹æ³•å¯ä»¥ç”¨æ–¼æ‰€æœ‰éœ€è¦æ–¹æ³•ç‰©ä»¶çš„åœ°æ–¹. èªæ³•é™åˆ¶ä¸Šæ˜¯ single expressionï¼Œå¯¦éš›ä¸Šä»–å€‘åªæ˜¯ä¸€èˆ¬æ–¹æ³•å®šç¾©çš„èªæ³•ç³–ï¼Œå¦‚åŒå·¢ç‹€æ–¹æ³•å®šç¾©, lambda æ–¹æ³•å¯ä»¥åƒè€ƒä»–çš„ containg scope çš„è®Šæ•¸

def make_incrementor(n):
    return lambda x: x + n

f = make_incrementor(42) # <class 'function'>
f(0) # 42
f(1) # 43

#ä¸Šè¿°ç¯„ä¾‹ä½¿ç”¨ lambda expression å›å‚³ä¸€å€‹ functionï¼Œä»¤ä¸€ç¨®ç”¨æ³•æ˜¯å°‡ä¸€å€‹å°æ–¹æ³•ä½œç‚ºåƒæ•¸å‚³é:

pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
pairs.sort(key=lambda pair: pair[1])
pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]

#
# Documentation Strings
#
def my_function():
    """Do nothing, but document it.

    No, really, it doesn't do anything.
    """
    pass
print(my_function.__doc__)
# ç¬¬ä¸€è©±é–‹é ­å¤§å¯«ï¼Œ.çµæŸï¼Œç´€éŒ„Summary
# å¤šè¡Œçš„è©±ï¼Œç¬¬äºŒè¡Œç©ºç™½

#
# Function Annotation
#
>>> def f(ham: str, eggs: str = 'eggs') -> str:
...     print("Annotations:", f.__annotations__)
...     print("Arguments:", ham, eggs)
...     return ham + ' and ' + eggs
...
>>> f('spam')
# Return annotations ä½¿ç”¨ -> è¡¨ç¤ºå›å‚³å‹æ…‹
# Parameter annotations åœ¨åƒæ•¸åç¨±ç”¨å†’è™Ÿå®šç¾©, å¾Œé¢æ¥è‘—å‹æ…‹

#
# Coding Style
#

# ç”¨4å€‹ç©ºç™½ï¼Œä¸ç”¨ tab
# æ–¹æ³•é¡åˆ¥é–“ç”¨ç©ºç™½è¡Œéš”é–‹
# ä½¿ç”¨ docstring
# é‹ç®—å­å…©å´è¦ç©ºç™½ï¼Œé€—è™Ÿå¾Œè¦ç©ºç™½ï¼Œ
# UpperCamelCase é¡åˆ¥å‘½åæ–¹å¼
# lowercase_with_underscores ç‚º function/method çš„å‘½åæ–¹å¼

#
# Scope
#

if, while, for å…§çš„è®Šæ•¸æ²’æœ‰local scope
fruits = ['apple','banana']

if 'apple' in fruits:
   new_fruit = 'fuji'

print(new_fruit) # å¯ä»¥è®€åˆ°new_fruitå°å‡º'fuji'

#
# import
#

import turtle

new_obj = turtle.Turtle()

æˆ–æ˜¯

from turtle import Turtle
new_obj = Turtle()

æˆ–æ˜¯

import turtle as t

new_obj = t.Turtle()

#
# æ‰“é–‹æª”æ¡ˆ
#

with ("my.txt") as file
    content = file.read()

å°‡å…§å®¹å¯«å…¥list
with ("my.txt") as file
    content = file.readlines()

å¯«å…¥
with ("my.txt", mode="w") as file
    content = file.write()

é™„åŠ 
with ("my.txt", mode="a") as file
    content = file.write() # append
    
strip() å°±æ˜¯ trim()

#
# List Comprehension
#

list = [1, 2, 3, 4, 5]

def multiply(num):
    return num * 3

new_list = [multiply(x + 1) for x in list]

print(new_list) # [6, 9, 12, 15, 18]

new_list = [multiply(x + 1) for x in list if x%2 == 0] # å¯ä»¥åŠ æ¢ä»¶

#
# Sequence
#
list, range, tuple, string
æ˜¯æœ‰é †åºçš„

#æ¯”è¼ƒå…©å€‹æª”æ¡ˆçš„å…§å®¹ï¼Œæ‰¾å‡ºä¸€è‡´çš„

file1 = open('file1.txt')
file2 = open('file2.txt')

file1_nums = file1.readlines()
file2_nums = file2.readlines()

result = [int(x) for x in file1_nums if x in file2_nums]

#
# Dictionary Comprehension
#

sentence = "What is the Airspeed Velocity of an Unladen Swallow?"
# Don't change code above ğŸ‘†

sep = sentence.split()

# Write your code below:

result = {x:len(x) for x in sep}

å¾DictåšDict Comprehension
sentence = "What is the Airspeed Velocity of an Unladen Swallow?"
# Don't change code above ğŸ‘†

sep = sentence.split()

# Write your code below:

result = {x:len(x) for x in sep}

result2 = {key:value for (key,value) in result.items() if value > 2} # æ³¨æ„èªæ³•

print(result2)

#
# Python æ˜¯ Dynamic Typing 
#

a = 4
print(id(a)) # 3152268755280
a = "4"
print(id(a)) # 3152269762224

#
# Python æ˜¯ Strongly Typing 
#

3 + "5" # error

#
# æŒ‡å®šè®Šæ•¸å‹åˆ¥ï¼Œä¹Ÿå¯ä»¥è¨­å®šæ–¹æ³•çš„åƒæ•¸
#
num:int
num = "e" # error
