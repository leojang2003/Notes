- 傳入參數

script名稱之後的其他參數，將轉換為list的strings指派給sys module的argv變數

舉例，呼叫 py sample.py p1 p2

檔案內容
import sys
print(argv[0]); // sample.py
print(argv[1]); // p1
print(argv[1]); // p2

- Python 原始檔預設以 UTF-8 編碼
- 變更編碼在檔案開頭新增
# -*- coding: cp1252 -*-

除法
17 / 3  # 回傳浮點數

除法
17 // 3  # 不回傳浮點數

次方
5 ** 2 # 25
2 ** 7  # 128

等號
>>>
>>> width = 20
>>> height = 5 * 9
>>> width * height
900

In interactive mode, the last printed expression is assigned to the variable _
>>>
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06

_是read-only

其他數字 Deciaml/Fraction

字串


單引號，雙引號皆可表示字串
>>> 'doesn\'t'  # "doesn't"
>>> "doesn't"   # "doesn't"
>>> '"Yes," they said.'   # '"Yes," they said.'
>>> "\"Yes,\" they said." # '"Yes," they said.' escaped
>>> '"Isn\'t," they said.'#

print()方法會忽略兩側closing quote並印出escaped/special字元
>>> '"Isn\'t," they said.' 		# '"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')	# "Isn't," they said.
>>> s = 'First line.\nSecond line.'  # 我們想要 \n 表示換行
>>> s  # 'First line.\nSecond line.' 沒有 print(), \n 會在 output

>>> print(s)  
First line.
Second line. # 會換行


使用r來表示raw string
>>> print('C:\some\name')  # \n視為換行
C:\some
ame
>>> print(r'C:\some\name')  # 字串前加r
C:\some\name

多行的字串
用"""...""" 或是 '''...'''

字串concate用+，重複用*
>>> 3 * 'un' + 'ium' #'unununium'

字串間的空白會自動連接
'Py' 'thon' # 'Python'
可以用來長句子換行
僅適用於string literals，變數不行，有變數的concate只能用+

Slicing :
沒有char型別，python只有長度1的字串
string可以indexed

>>> word = 'Python'
>>> word[0]   # 'P' 第1個
>>> word[-1]  # 'n' 倒數第1個
>>> word[-2]  # 'o' 倒數第2個
>>> word[-6]  # 'P' 倒數第6個

負數index從-1開始算起

>>> word[0:2]  # 'Py' 0 (包含) 到 2 (不包含)
>>> word[2:5]  # 'tho' 2 (包含) 到 5 (不包含)
>>> word[:2]   # 'Py' 開始到 position 2 (不包含)
>>> word[4:]   # 'on' 4 (包含) 到結束
>>> word[-2:]  # 'on' -1 (包含) 到結束

Slicing可以處理out of range
>>> word[4:42] # 'on'
>>> word[42:]  # '' 

字串也是immutable
>>> word[0] = 'J' # 錯誤

字串長度 len()

*** Lists ***

squares = [1, 4, 9, 16, 25] // 用中括號，逗號隔開
>>> squares[0]  # 1
>>> squares[-1] # 25
>>> squares[-3:]  # 回傳新的 list [9, 16, 25]
slicing 會回傳新的 list

>>> squares[:] # 回傳一個全新一樣的list [1, 4, 9, 16, 25]

list也可以concate
>>> squares + [36, 49, 64, 81, 100] # 回傳 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

list是mutable的，與string不同
>>> cubes = [1, 8, 27, 65, 125]  
>>> cubes[3] = 64  
>>> cubes # [1, 8, 27, 64, 125] 成功置換

>>> cubes.append(216)  # 加到尾
>>> cubes.append(7 ** 3)  # 加到尾
>>> cubes # [1, 8, 27, 64, 125, 216, 343]

置換list中的元素
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters # ['a', 'b', 'C', 'D', 'E', 'f', 'g'] 中間的物件被換了

移除list中的元素
>>> letters[2:5] = []
>>> letters # ['a', 'b', 'f', 'g'] 中間的物件被移除了

清空list
letters[:] = []

list長度len()
>>> len(letters) # 4

list裡包含list
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x # [['a', 'b', 'c'], [1, 2, 3]]
>>> x[0] # ['a', 'b', 'c']
>>> x[0][1] #b

多重assignment
>>> a, b = 0, 1

右側的expression在assignment前會先被執行。
>>> a, b = b, a+b

右側的表達式從左到右計算。
... a, b = 0, 1
>>> while a < 10:
...		a, b = b, a+b # a+b 會先執行
...     print('a=',a , 'b=', b);
...     
a= 1 b= 1 # print 的結果之間會自動有空白
a= 1 b= 2
a= 2 b= 3
a= 3 b= 5
a= 5 b= 8
a= 8 b= 13
a= 13 b= 21

while迴圈內容>0為True，0為False
任何長度>0的物件在while迴圈內都是True，

print() 的結果之間會自動有空白

單引號字串，不用escape雙引號
雙引號字串，不用escape單引號

>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
...     x = 0
...     print('Negative changed to zero')
... elif x == 0:
...     print('Zero')
... else:
...     print('More')

另外 if elif 可用來取代其他語言的 switch

for迴圈
>>> words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print(w, len(w))

iterate collection時同時要修改collection容易出錯，通常的做法是複製一個新的collection

# 建立一個 sample collection (此處使用的是dict)
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}
print(type(users)); # <class 'dict'>

另一種建立dict的方式
users = dict()

users['a'] = 'A'
users['a'] = 'B' # 取代
print(users['a'] )  # B

users['b'] # 錯誤
users.get('b') # 無資料時回傳 None <class 'NoneType'>
users.get('b', 'tbd') # 無資料時回傳自訂字串
users.get('b', 20) # 無資料時回傳也可自訂型別

一次更新多筆可用update()
new_users = {'John': 'active', 'Snow': 'inactive', 'Rick0': 'active'}
users.update(new_users) #將new_users加入users

刪除
del users[key]

刪除後取得value
tmp = users.pop(key)

取得所有keys
users.keys()
dict_keys(['Hans', 'Éléonore', '景太郎', 'John', 'Snow', 'Rick0']) #<class 'dict_keys'>

取得所有values
users.values()
dict_values(['active', 'inactive', 'active', 'active', 'inactive', 'active']) #<class 'dict_values'>

取得所有key/value
users.items()

是否有KEY
'key' in users # 回傳True或False

==可判斷兩個dict是否含有相同的key/value組合，順序不重要
 
is運算子可判斷是否為相同的物件
print(users is new_users) # 回傳False


dict類似HashMap，key值唯一
取得value使用users[key]

# Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Strategy:  Create a new collection
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status

range() 方法
>>> for i in range(5): # 0-4
...     print(i)  # 0 1 2 3 4 5

>>> list(range(5, 10)) # 可以設定起始數字 [5, 6, 7, 8, 9] <class 'list'>
>>> list(range(0, 10, 3)) # 可以設定間隔 [0, 3, 6, 9]
>>> list(range(-10, -100, -30)) #[-10, -40, -70]

巡迴list的方法
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
...     print(i, a[i])

range(10) 回傳一個 range(0, 10) <class 'range'>

>>> sum(range(4))  # 0 + 1 + 2 + 3
6

這個else是針對內層的for迴圈，當for迴圈無break時則會執行else
>>> for n in range(2, 10):
...     for x in range(2, n):
...         if n % x == 0:
...             print(n, 'equals', x, '*', n//x)
...             break
...     else:
...         # loop fell through without finding a factor
...         print(n, 'is a prime number')

pass 
本身沒用途，算是一個placeholder，常用於建立一個空的類別
>>> class MyEmptyClass:
...     pass

或是用於方法當作placeholder
>>> def initlog(*args):
...     pass   # Remember to implement this!

# match有以下pattern
#
# Literal Patterns
# Wildcard Patterns
# OR Pattern
# AS Pattern
#
def http_error(status):
    match status:
        # literal pattern
        case 400:
            return "Bad request"
        # OR pattern / AS Pattern
        case 401 | 403 | 404 as errorCode: 
            return "Not allowed"
        # wildcard pattern 
        case _:
            return "Something's wrong with the internet"

# Wildcard Patterns 中的 _ 可以 match 所有物件，規定只能放最後
# 因為 OR Patterns 無法分辨內容，所以用 as 將值 bind 到變數

# 
# Capture Patterns
#
def point(point):
    match point: # 這裡定義的 point 是 tuple(aka 不能修改的list)
        case (0, 0):
            print("Origin")        
        case (x, 0):
            print(f"X={x}") # 會做 bind
        case (x, y): # 如同 Unpacking Assignment (x, y) = point.
            print(f"X={x}, Y={y}")

# 
# Class Patterns
#
class Point:
    x: int
    y: int

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Origin")
        case Point(x=0, y=y):
            print(f"Y={y}")
        case Point(x=x, y=0):
            print(f"X={x}")
        case Point():
            print("Somewhere else")
        case _:
            print("Not a point")

# 自訂的 class 需在 pattern 中指定屬性名稱
# 有兩個方法可以不用指定屬性名稱
# 1. 使用 dataclass：這可以讓 class 實例的屬性擁有'順序'(positional argument)，無需在 pattern 中指定屬性名稱
# 2. 定義__match_args__

from dataclasses import dataclass

command = input("what are you doing next")

# [action, action2] = command.split() # 如果輸多於2個，unpack會失敗

match command.split():
	case [action]: # 只有輸入1個字
		print('action only')
	case [action, obj]: # 輸入2個字
		print('action and obj')

match command.split():
    case ["quit"]:
        print("Goodbye!")        
    case ["look", obj] if obj == 'left': # uf 即所謂的 Guard
        print("look left!")        
    case ["get", obj]: # get 跟 go 的變數名稱可以設成不同
        print("get!") 
    case ["go", direction]: # get 跟 go 的變數名稱可以設成不同
        print("go!")

		
match command.split():
    case ["drop", *objects]:
        print(type(objects)) #<class 'list'>
        for obj in objects:
            print(obj)
    case _:
        print('wildcard')
# 如同 sequence unpacking，一個pattern不可有超過一個*


doom = ["first", ("l", "r"), "a", "b", "c"]

match doom:
    case ["first", (left, right), *rest]:
        print(type(rest)) 
        for obj in rest:
            print(obj) # a b c
        print(left, right) # l r
    case _:
        print('wildcard')
		
match command.split():    
    case ["north"] | ["go", "north"]:
        print("north")
    case ["get", obj] | ["pick", "up", obj] | ["pick", obj, "up"]:
        print('56')
		
match command.split():    
    case ["north"] | ["go", "north"]:
        print("north")
    #下面會錯誤，alternative patterns bind different names
    #case ["get", obj, obj2] | ["pick", "up", obj] | ["pick", obj, "up"]:
        #print('50')
# Or pattern 下同一個pattern的alternatives必須綁定一樣的變數
# [1, x] | [2, y] 不行
# [1, x] | [2, x] 可以

# 將OR的結果存入direction
match command.split():
    case ["go", ("north" | "south" | "east" | "west") as direction]:
        print(direction)
		
match command.split():
    case ["go", "north"] | ["go", "south"] | ["go", "east"] | ["go", "west"] as direction:
        print(direction)

class Room:
	exits:list

current_room = Room()
current_room.exits = ["north","south"]
		
match command.split():
    case ["go", direction] if direction in current_room.exits:
        print(direction)
    case ["go", _]:
        print("Sorry, you can't go that way")

class Person:	
	fname:str
	lname:str
	age:int
	
john = Person()
john.fname = 'John'
john.lname = 'Wicks'

match john:	
	# match named attribute 如下
	case Person(lname='Wicks', fname='John'): # 順序交換，可以match
		print('1st John')
	case Person('John', 'Wicks'): # Person accepts 0 positional sub-patterns (2 given)
		print('1st John')
	case Person(fname='John', lname='Wicks'): # 可以match
		print('2nd John')
		
# 上面的錯誤需要加入 __match_args__ = ("position", "button")

class Person:	
	__match_args__ = ("fname", "lname") # 設定
	fname:str
	lname:str
	age:int
	
john = Person()
john.fname = 'John'
john.lname = 'Wicks'

match john:
	# 不需要match named attribute，因為設定了__match_args__
	case Person('John', 'Wicks'): # 可以match了
		print('1st John')
	case Person(lname='Wicks', fname='John'): # 順序交換，可以match
		print('1st John')
	case Person(fname='John', lname='Wicks'): # 可以match
		print('2nd John')

#定義dataclass的話也定義positional arguments，'fname', 'lname', and 'age'
#這三個arguments是有順序的

@dataclass
class Person:	
	fname:str
	lname:str
	age:int
	
john = Person('John','Wicks',20) # 初始化 dataclass

match john:	
	case Person('John', 'Wicks'): # 可以match
		print('1st John')
	case Person(lname='Wicks', fname='John'): 
		print('1st John')	
	case Person(fname='John', lname='Wicks'): 
		print('2nd John')
#
# Mapping pattern
#
# {"bandwidth": b, "latency": l} 取得 "bandwidth" 與 "latency" 的值從dict. 
# 不像 sequence patterns, 其他的KEY被忽略了.使用 **rest 可以保留其他的KEY. (但是 **_ 是不被允許的)
	
actions = [{"text": "The shop keeper says 'Ah! We have Camembert, yes sir'", "color": "blue", "name":"Doc Rivers","age":65,"team":"LA Clippers"}
,{"sleep": 3},{"sound": "filename.ogg", "format": "ogg"}]

# 這裡的**rest就是一個 kwargs (k-word-args)

for action in actions:
    match action:
        case {"text": message, "color": c, **rest}:
            print(type(rest)) #<class 'dict'>
            for key in rest:
                print(key, rest[key])
            print('color=',c)
            print('message=',message)
        case {"sleep": duration}:
            print('sleep=',c)
        case {"sound": url, "format": "ogg"}:
            print('url=',url)
        case {"sound": _, "format": _}:
            warning("Unsupported audio format")

#
# 比對內建型別 Matching builtin classes
#

for action in actions:
    match action:
        case {"text": str(message), "color": str(c)}:            
            print('do something 2')
        case {"sleep": float(duration)}:
            print('do something 3')
        case {"sound": str(url), "format": "ogg"}:
            print('do something 4')
        case {"sound": _, "format": _}:
            warning("Unsupported audio format")
# {"text": str() as message, "color": str() as c}
# 確保text和color都是str，上述寫法也可以縮減成如下
# {"text": str(message), "color": str(c)}

#
# Sequence Pattern
#
# [x, y, *rest] and (x, y, *rest) 都用於 unpacking assignments. * 號後也可以是 _，像 (x, y, *_)，如此只會bind兩個變數，其他不會

		
food = ['a','b','c','d','k']
match food:
	# case ['a','b','c', _]:
		# print("wild")
	case ['a','b','d', *other]:
		print(f"{','.join(other)}'")
	case ['a', *other, 'e']:
		print(f"{','.join(other)}'")
	case['a', _] if "c" in food:
		print('in')
	case {"a":"", **kwargs}:
		print('desert')



https://25349023.github.io/articles/2021-03/py-structural-pattern-matching/
https://medium.com/short-bits/python-3-10-match-a-new-way-to-find-patterns-8452d1460407
https://peps.python.org/pep-0635/
https://benhoyt.com/cv/#about-me
https://www.geeksforgeeks.org/python-star-or-asterisk-operator/

#
# Python 指派值的方式說明 call-by-assignment
#
# Assigning to a variable name in Python makes the name bind to a different value 
# from what it currently was bound to (if indeed it was already bound), 
# rather than changing the value it currently binds to:

# 將一個值指派給一個變數名稱，表示該名稱會bind到一個不同的值(value)
# 而不是原來bind的值，指派這個動作並非變更原先bind的值

a = 7   # Create 7, bind a to it.
        #     a -> 7

b = a   # Bind b to the thing a is currently bound to.
        #     a
        #      \
        #       *-> 7
        #      /
        #     b

a = 42  # Create 42, bind a to it, b still bound to 7.
        #     a -> 42
        #     b -> 7


# Where the underlying data is immutable (cannot be changed), that usually makes Python look as if it's behaving identically 
# to the way other languages do (C and C++ come to mind). That's because the 7 (the actual object that the names are bound to) cannot be changed.

# But, for mutable data (same as using pointers in C or references in C++), 
# people can sometimes be surprised because they don't realise that the value behind it is shared:

a = [1,2,3]     # a -> [1,2,3]
print(a) # [1, 2, 3]

b = a           # a,b -> [1,2,3]
print(b) # [1, 2, 3]

a[1] = 42       # a,b -> [1,42,3]
print(a) 
print(b)
# 都是 [1, 42, 3]

# You need to understand that a[1] = 42 is different to a = [1, 42, 3]. The latter is an assignment, 
# which would result in a being re-bound to a different object, and therefore independent of b.

# 重點 : 如果用 = 指派新的值到變數名稱，像 a = [1,42,3]，b 還是會指向原本的 [1,2,3]

def set_list(list):
    list = ["A", "B", "C"]
    return list
 
def add(list):
    list.append("D")
    return list
 
my_list = ["E"]
 
print(set_list(my_list))
 
print(add(my_list))


# The former is simply changing the mutable data that both a and b are bound to, which is why it affects both.


# 另一篇說法

If you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.

If you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object.

例如 def foo(bar): 這個 function 的參數傳遞，其實是在 foo 的 local namespace 裡幫傳進去的物件綁定了一個叫做 bar 的名字（所謂的 assignment）；如果你在 foo 裡 re-assign 了一個新的物件給 bar，實際上是把 bar 這個名字綁定到那個新的物件。

mutable objects: list, dict, set 的行為同 call-by-reference
immutable objects: boolean, int, float, long, str, unicode, tuple 的行為同 call-by-value
不過如果你把一個 mutable 物件放進 immutable 物件裡，例如把 list 放進 tuple 裡，則修改了 list 之後，那個 tuple 裡的 list 也是會被修改。

a_list = [1, 2, 3]
a_tuple = (a_list, 'a', 'b', 'c')
a_list.append(4)
Assignment is the binding of a name to an object: name = 'Molly'.
Assignment between names doesn't create a new object, both names are simply bound to the same object: nickname = name.

name = 'Mollie'
name = 'Vinta'
所謂的 assign 這個動作，其實是幫 'Mollie' 這個字串取一個名字叫做 name，所以如果你又加上一句 name = 'Vinta'，實際上是建立了一個新的物件（字串 'Vinta'），再把這個新字串綁定到 name 這個名字。

# if bar refers to a mutable object
def foo(bar):
    bar.append('new value')
    print(bar)
    # output: ['old value', 'new value']

answer_list = ['old value', ]
foo(answer_list)
print(answer_list)
# output: ['old value', 'new value']

# if bar refers to an immutable object
def foo(bar):
    bar = 'new value'
    print(bar)
    # output: 'new value'

answer_list = 'old value'
foo(answer_list)
print(answer_list)
# output: 'old value'

# if bar refers to a mutable object and re-assign it in foo
def foo(bar):
    bar = ['new value', ]
    print(bar)
    # output: ['new value', ]

answer_list = ['old value', ]
foo(answer_list)
print(answer_list)
# output: ['old value', ]
